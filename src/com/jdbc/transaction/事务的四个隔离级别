


问题的提出
数据库是要被广大客户所共享访问的，那么在数据库操作过程中很可能出现以下几种不确定情况。

折叠更新丢失
两个事务都同时更新一行数据，一个事务对数据的更新把另一个事务对数据的更新覆盖了。
这是因为系统没有执行任何的锁操作，因此并发事务并没有被隔离开来。

折叠脏读
一个事务读取到了另一个事务未提交的数据操作结果。这是相当危险的，因为很可能所有的操作都被回滚。

折叠不可重复读
不可重复读(Non-repeatable Reads):一个事务对同一行数据重复读取两次，但是却得到了不同的结果。

包括以下情况:

(1) 虚读:事务T1读取某一数据后，事务T2对其做了修改，当事务T1再次读该数据时得到与前一次不同的值。

(2) 幻读(Phantom Reads):事务在操作过程中进行两次查询，第二次查询的结果包含了第一次查询中未出现的数据
或者缺少了第一次查询中出现的数据(这里并不要求两次查询的SQL语句相同)。这是因为在两次查询过程中有另外一个事务插入数据造成的。

折叠编辑本段解决方案
为了避免上面出现的几种情况，在标准SQL规范中，定义了4个事务隔离级别，不同的隔离级别对事务的处理不同。

1.未授权读取

也称为读未提交(Read Uncommitted):允许脏读取，但不允许更新丢失。如果一个事务已经开始写数据，则另外一个事务则不允许同时进行写操作，
但允许其他事务读此行数据。该隔离级别可以通过"***排他写锁***"实现。

2.授权读取

也称为读提交(Read Committed):允许不可重复读取，但不允许脏读取。这可以通过"瞬间共享读锁"和"排他写锁"实现。
读取数据的事务允许其他事务继续访问该行数据，但是未提交的写事务将会禁止其他事务访问该行。

3.可重复读取(Repeatable Read)

可重复读取(Repeatable Read):禁止不可重复读取和脏读取，但是有时可能出现幻读数据。这可以通过"共享读锁"和"排他写锁"实现。
读取数据的事务将会禁止写事务(但允许读事务)，写事务则禁止任何其他事务。

4.序列化(Serializable)

序列化(Serializable):提供严格的事务隔离。它要求事务序列化执行，事务只能一个接着一个地执行，不能并发执行。
仅仅通过"行级锁"是无法实现事务序列化的，必须通过其他机制保证新插入的数据不会被刚执行查询操作的事务访问到。

隔离级别越高，越能保证数据的完整性和一致性，但是对并发性能的影响也越大。
对于多数应用程序，可以优先考虑把数据库系统的隔离级别设为Read Committed。它能够避免脏读取，而且具有较好的并发性能。
尽管它会导致不可重复读、幻读和第二类丢失更新这些并发问题，在可能出现这类问题的个别场合，可以由应用程序采用悲观锁或乐观锁来控制。